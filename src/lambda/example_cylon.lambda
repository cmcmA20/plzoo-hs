pair := λλλ _0 _2 _1 ;
first := λ _0 (λλ _1) ;
second := λ _0 (λλ _0) ;

-- The constant function

K := λλ _1 ;

-- Booleans

true  := λλ _1 ;
false := λλ _0 ;
if := λ _0 ;

and := λλ if _1 _0 false ;
or  := λλ if _1 true _0 ;
not := λ if _0 false true ;

-- Recursive definitions

fix := λ (λ _1 (_0 _0)) (λ _1 (_0 _0)) ;

-- Lists

:constant error

nil := λλ _1 ;

cons := λλλλ _0 _3 _2 ;

head := λ _0 error (λλ _1) ;

tail := λ _0 error (λλ _0) ;

match := λλλ _2 _1 _0 ;

map := fix (λλλ match _0 nil (λλ cons (_3 _1) (_4 _3 _0))) ;

fold := fix (λλλλ match _0 _2 (λλ _3 y (_5 _4 _3 _0))) ;

-- Numbers

0  := λλ 0 ;
1  := λλ 1 0 ;
2  := λλ 1 (1 0) ;
3  := λλ 1 (1 (1 0)) ;
4  := λλ 1 (1 (1 (1 0))) ;
5  := λλ 1 (1 (1 (1 (1 0)))) ;
6  := λλ 1 (1 (1 (1 (1 (1 0))))) ;
7  := λλ 1 (1 (1 (1 (1 (1 (1 0)))))) ;
8  := λλ 1 (1 (1 (1 (1 (1 (1 (1 0))))))) ;
9  := λλ 1 (1 (1 (1 (1 (1 (1 (1 (1 0)))))))) ;
10 := λλ 1 (1 (1 (1 (1 (1 (1 (1 (1 (1 0))))))))) ;

succ := λλλ _1 (_2 _1 _0) ;

+ := λλλλ (_3 _1) ((_2 _1) _0) ;

* := λλλλ (_3 (_2 _1)) _0 ;

** := λλ _0 _1 ;

iszero := λ (_0 (K false)) true ;

pred := λ second (_0 (λ pair (succ (first _0)) (first _0)) (pair _0 _0)) ;

== := fix (λλλ if (iszero _1) (iszero _0) (_2 (pred _1) (pred _0))) ;

fact := fix (λλ if (iszero _0) 1 (* _0 (_1 (pred _0)))) ;

<= := λλ iszero (_0 pred _1) ;

>= := λλ iszero (_1 pred _0) ;

< := λλ <= (succ _1) _0 ;

> := λλ >= _1 (succ _0) ;

mu := fix (λλλ if (_0 _1) _1 (_2 (succ _1) _0)) 0 ;

/ := λλ mu (λ > (* (succ _0) _1) _2) ;

| := λλ == (* _1 (/ _0 _1)) _0 ;

all := λλλ fix (λλ if (> _0 _3) true (if (_2 _0) (_1 (succ _0)) false)) _2 ;

prime := λ all 2 (/ _0 2) (λ not (| _0 _1)) ;
