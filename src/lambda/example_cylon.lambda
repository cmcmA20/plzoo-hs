pair := λλλ 0 2 1 ;
first := λ 0 (λλ 1) ;
second := λ 0 (λλ 0) ;

-- The constant function

K := λλ 1 ;

-- Booleans

true  := λλ 1 ;
false := λλ 0 ;
if := λ 0 ;

and := λλ if 1 0 false ;
or  := λλ if 1 true 0 ;
not := λ if 0 false true ;

-- Recursive definitions

fix := λ (λ 1 (0 0)) (λ 1 (0 0)) ;

-- Lists

:constant error

nil := λλ 1 ;

cons := λλλλ 0 3 2 ;

head := λ 0 error (λλ 1) ;

tail := λ 0 error (λλ 0) ;

match := λλλ 2 1 0 ;

map := fix (λλλ match 0 nil (λλ cons (3 1) (4 3 0))) ;

fold := fix (λλλλ match 0 2 (λλ 3 y (5 4 3 0))) ;

-- Numbers

_0  := λλ 0 ;
_1  := λλ 1 0 ;
_2  := λλ 1 (1 0) ;
_3  := λλ 1 (1 (1 0)) ;
_4  := λλ 1 (1 (1 (1 0))) ;
_5  := λλ 1 (1 (1 (1 (1 0)))) ;
_6  := λλ 1 (1 (1 (1 (1 (1 0))))) ;
_7  := λλ 1 (1 (1 (1 (1 (1 (1 0)))))) ;
_8  := λλ 1 (1 (1 (1 (1 (1 (1 (1 0))))))) ;
_9  := λλ 1 (1 (1 (1 (1 (1 (1 (1 (1 0)))))))) ;
_10 := λλ 1 (1 (1 (1 (1 (1 (1 (1 (1 (1 0))))))))) ;

succ := λλλ 1 (2 1 0) ;

+ := λλλλ (3 1) ((2 1) 0) ;

* := λλλλ (3 (2 1)) 0 ;

** := λλ 0 1 ;

iszero := λ (0 (K false)) true ;

pred := λ second (0 (λ pair (succ (first 0)) (first 0)) (pair 0 0)) ;

== := fix (λλλ if (iszero 1) (iszero 0) (2 (pred 1) (pred 0))) ;

fact := fix (λλ if (iszero 0) _1 (* 0 (1 (pred 0)))) ;

<= := λλ iszero (0 pred 1) ;

>= := λλ iszero (1 pred 0) ;

< := λλ <= (succ 1) 0 ;

> := λλ >= 1 (succ 0) ;

mu := fix (λλλ if (0 1) 1 (2 (succ 1) 0)) _0 ;

/ := λλ mu (λ > (* (succ 0) 1) 2) ;

| := λλ == (* 1 (/ 0 1)) 0 ;

all := λλλ fix (λλ if (> 0 3) true (if (2 0) (1 (succ 0)) false)) 2 ;

prime := λ all _2 (/ 0 _2) (λ not (| 0 1)) ;
